<link rel="import" href="../../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../../bower_components/drag-element/drag-element.html">
<link rel="import" href="../../../bower_components/drag-element/drag-element-styles.html">
<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../diff/hunk-highlighter.html">
<link rel="import" href="../diff/hunk-sorter.html">
<link rel="import" href="../diff/diff-parser.html">
<link rel="import" href="group-block.html">

<dom-module id="group-editor">
  <template>
    <style include="drag-element-styles">
      :host {
        display: block;
      }
      header {
        margin: 0 2em;
        border-bottom: solid 1px var(--secondary-text-color);
        margin-bottom: 1em;
        padding-bottom: 1em;
        display: flex;
      }
      header h2 {
        margin: 0;
        font-weight: 300;
        flex: 1
      }
      header .add {
        background-color: var(--primary-background-color);
        padding: 2px;
        padding: 0.5em;
        height: 2em;
        width: auto;
      }
      #groups {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
      }
      group-block {
        margin: 0.65em;
      }
      .mirror,
      .shadow,
      .dragging {
        animation: none;
        opacity: 0.5;
      }

      hunk-highlighter {
        margin: 1em;
      }
      .mirror {
        overflow: hidden;
        max-height: 150px;
        max-width: 300px;
      }
      .list {
        max-width: 960px;
        margin: 0 auto;
      }

      .createBtn {
        display: block;
        background-color: var(--primary-action-green);
        color: white;
        margin: 0 auto;
        margin-bottom: 1em;
        width: 220px;
        text-align: center;
        margin-top: 2em;
      }
    </style>

    <diff-parser 
      diff="[[diff]]" 
      base-url="[[baseUrl]]" 
      hunks="{{hunks}}"
      ></diff-parser>
    <hunk-sorter 
      id="sorter" 
      raw-hunks="[[hunks]]" 
      ordered-groups="{{orderedGroups}}" 
      unordered-group="{{unorderedGroup}}" 
      pull-request="[[pullRequest]]"
      ></hunk-sorter>

    <header>
      <h2>Create and edit groups</h2>
      <paper-button raised class="add" icon="add" on-tap="_newGroup"><iron-icon icon="add"></iron-icon>Add</paper-button>
    </header>

    <drag-element id="groups" handle-selector=".dragHandle">
      <template id="sortedRepeat" is="dom-repeat" items="[[orderedGroups]]">
        <group-block group="{{item}}"></group-block>
      </template>
    </drag-element>

    <paper-button raised hidden=[[!enableNext]] class="createBtn" on-tap="_fireCreatePull">
      Create Pull Request<iron-icon icon="check"></iron-icon>
    </paper-button>

    <header>
      <h2>Imported changes from GitHub</h2>
    </header>

    <drag-element 
      id="unsorted" 
      handle-selector=".dragHandle" 
      container-selector=".list"
      link-identifier="group-editor">
      <div class="list">
        <template id="unsortedRepeat" is="dom-repeat" items="[[unorderedHunks]]" as="hunk">
          <hunk-highlighter hunk="[[hunk]]"></hunk-highlighter>
        </template>
      </div>
    </drag-element>


  </template>
  <script>
    Polymer({
      is: 'group-editor',

      properties: {
        baseUrl: String,
        diff: String,
        hunks: {
          type: Array,
          value: function() {
            return [];
          }
        },
        orderedGroups: {
          type: Array,
          notify: true
        },
        unorderedGroup: {
          type: Object,
          notify: true,
          observer: '_onUnsortedChange'
        },
        unorderedHunks: Array,

        _cachedHunkShadow: Object,
        _cachedHunkMirror: Object,
        pullRequest: Object
      },
      
      attached: function() {
        this.$.unsorted.createMirror = this._copyHunkMirror.bind(this);
        this.$.unsorted.createShadow = this._copyHunkShadow.bind(this);
        this.$.unsorted.canDrop = function() { return false; };
      },
      

      listeners: {
        'add-hunk-to-group': '_addHunk',
        'remove-hunk-from-group': '_removeHunk',
        'move-hunk': '_moveHunk',
        'remove-hunk': '_removeUnorderedHunk',
        'remove-group': '_removeGroup',
        'drag-finish': '_moveGroup'
      },

      _copyHunkShadow: function(el) {
        if (!this._cachedHunkShadow) {
          this._cachedHunkShadow = el.cloneNode();
        }
        this._cachedHunkShadow.hunk = el.hunk;
        return this._cachedHunkShadow;
      },

      _copyHunkMirror: function(el) {
        if (!this._cachedHunkMirror) {
          this._cachedHunkMirror = el.cloneNode();
        }
        this._cachedHunkMirror.hunk = el.hunk;
        return this._cachedHunkMirror;
      },

      _addHunk: function(e) {
        e.stopPropagation();
        this.$.sorter.addHunkToGroup(e.detail.hunk, e.detail.groupId, e.detail.toIndex);
      },

      _removeHunk: function(e) {
        e.stopPropagation();
        this.$.sorter.removeHunkFromGroup(e.detail.groupId, e.detail.hunk);
      },

      _moveHunk: function(e) {
        e.stopPropagation();
        this.$.sorter.moveHunk(e.detail.groupId, e.detail.fromIndex, e.detail.toIndex);
      },
      
      _removeUnorderedHunk: function(e) {
        e.stopPropagation();
        this.$.sorter.removeHunkFromGroup(this.unorderedGroup.id, e.detail.dragElement.hunk);
        this.unorderedHunks = this.unorderedGroup.diff;
        e.detail.dragElement.remove();
      },

      _removeGroup: function(e) {
        e.stopPropagation();
        this.$.sorter.removeGroupIfEmpty(e.detail.groupId);
        this.$.sortedRepeat.render();
      },

      _moveGroup: function(e) {
        if (e.detail.source !== this.$.unsorted) {
          this.$.sorter.moveGroup(e.detail.sourceElementIndex, e.detail.destElementIndex);
        }
      },

      _newGroup: function () {
        this.$.sorter.addGroup();
      },

      _onUnsortedChange: function() {
        if (this.unorderedGroup) {
          this.unorderedHunks = this.unorderedGroup.diff;
          this.$.unsortedRepeat.render();
          if (this.unorderedHunks.length > 0 && this.orderedGroups.length === 0) {
            this._newGroup();
          }
        }
      },

      _fireCreatePull: function() {
        this.fire('submit-pull-request', {
          ordering: this.$.sorter.getOrdering()
        });
      }

    });
  </script>
</dom-module>
